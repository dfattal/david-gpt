/**
 * Enhanced Citation Persistence System
 * 
 * Manages citation storage, retrieval, and fact summarization persistence
 * for multi-turn conversation context management.
 */

import { supabase } from '@/lib/supabase';
import type { 
  FactSummary,
  SearchResult,
  MessageCitation,
  ConversationSource 
} from './types';

// =======================
// Citation Management Types
// =======================

export interface CitationPersistenceOptions {
  extractFacts: boolean;
  updateCarryScore: boolean;
  maintainCitationOrder: boolean;
  enableFactSummarization: boolean;
}

export interface CitationBatch {
  messageId: string;
  conversationId: string;
  citations: EnhancedCitation[];
  totalCitations: number;
  factsExtracted: number;
}

export interface EnhancedCitation extends MessageCitation {
  stableCitationId?: string;
  authorityScore?: number;
  extractedFacts?: string[];
  documentMetadata?: {
    title: string;
    docType: string;
    publishedDate?: string;
    authorityLevel: 'high' | 'medium' | 'low';
  };
}

export interface CitationRetrievalOptions {
  includeFactSummaries: boolean;
  includeMetadata: boolean;
  sortByRelevance: boolean;
  limitResults?: number;
}

// =======================
// Citation Persistence Manager
// =======================

export class CitationPersistenceManager {
  private conversationId: string;
  private options: CitationPersistenceOptions;

  constructor(
    conversationId: string,
    options: Partial<CitationPersistenceOptions> = {}
  ) {
    this.conversationId = conversationId;
    this.options = {
      extractFacts: true,
      updateCarryScore: true,
      maintainCitationOrder: true,
      enableFactSummarization: true,
      ...options
    };
  }

  /**
   * Persist citations with fact summaries and enhanced metadata
   */
  async persistCitations(
    messageId: string,
    searchResults: SearchResult[],
    factSummaries: FactSummary[] = []
  ): Promise<CitationBatch> {
    console.log(`ðŸ’¾ Persisting ${searchResults.length} citations for message ${messageId}`);

    const citations: EnhancedCitation[] = [];
    let factsExtracted = 0;

    for (let i = 0; i < searchResults.length; i++) {
      const result = searchResults[i];
      const factSummary = factSummaries.find(f => f.sourceId === result.documentId);
      
      // Generate stable citation ID
      const stableCitationId = this.generateStableCitationId(result.documentId, result.docType);
      
      // Extract key facts if fact summarization is enabled
      let extractedFacts: string[] = [];
      let factSummaryText = '';
      
      if (this.options.enableFactSummarization && factSummary) {
        extractedFacts = factSummary.bullets;
        factSummaryText = extractedFacts.join(' â€¢ ');
        factsExtracted++;
      } else if (this.options.extractFacts) {
        // Fallback: extract simple fact from content
        const sentences = result.content.split(/[.!?]+/).filter(s => s.trim().length > 20);
        const topSentence = sentences
          .sort((a, b) => this.scoreSentence(b) - this.scoreSentence(a))[0];
        if (topSentence) {
          extractedFacts = [topSentence.trim()];
          factSummaryText = topSentence.trim();
          factsExtracted++;
        }
      }

      const citation: EnhancedCitation = {
        id: '', // Will be generated by database
        messageId,
        documentId: result.documentId,
        chunkId: result.chunkId,
        marker: `[${i + 1}]`,
        factSummary: factSummaryText || undefined,
        pageRange: result.pageRange,
        relevanceScore: result.score,
        citationOrder: i + 1,
        createdAt: new Date(),
        stableCitationId,
        authorityScore: this.calculateAuthorityScore(result),
        extractedFacts,
        documentMetadata: {
          title: result.title,
          docType: result.docType,
          publishedDate: this.extractPublishedDate(result),
          authorityLevel: this.getAuthorityLevel(result)
        }
      };

      citations.push(citation);
    }

    // Store citations in database
    await this.storeCitationsInDatabase(citations);

    // Update conversation sources if enabled
    if (this.options.updateCarryScore) {
      await this.updateConversationSources(searchResults, factSummaries);
    }

    const batch: CitationBatch = {
      messageId,
      conversationId: this.conversationId,
      citations,
      totalCitations: citations.length,
      factsExtracted
    };

    console.log(`âœ… Citation persistence complete: ${citations.length} citations, ${factsExtracted} facts`);
    return batch;
  }

  /**
   * Retrieve citations for a conversation with enhanced options
   */
  async retrieveCitations(
    messageId?: string,
    options: CitationRetrievalOptions = {
      includeFactSummaries: true,
      includeMetadata: true,
      sortByRelevance: true
    }
  ): Promise<EnhancedCitation[]> {
    let query = supabase
      .from('message_citations')
      .select(`
        *,
        documents (
          title,
          doc_type,
          published_date,
          granted_date,
          filed_date
        )
      `);

    if (messageId) {
      query = query.eq('message_id', messageId);
    } else {
      // Get all citations for conversation
      const { data: messages } = await supabase
        .from('messages')
        .select('id')
        .eq('conversation_id', this.conversationId);

      if (messages && messages.length > 0) {
        const messageIds = messages.map(m => m.id);
        query = query.in('message_id', messageIds);
      }
    }

    if (options.sortByRelevance) {
      query = query.order('relevance_score', { ascending: false });
    }

    if (options.limitResults) {
      query = query.limit(options.limitResults);
    }

    const { data: citations, error } = await query;

    if (error) {
      console.error('Error retrieving citations:', error);
      return [];
    }

    // Transform to enhanced citations
    const enhancedCitations: EnhancedCitation[] = (citations || []).map(citation => ({
      id: citation.id,
      messageId: citation.message_id,
      documentId: citation.document_id,
      chunkId: citation.chunk_id,
      marker: citation.marker,
      factSummary: citation.fact_summary,
      pageRange: citation.page_range,
      relevanceScore: citation.relevance_score,
      citationOrder: citation.citation_order,
      createdAt: new Date(citation.created_at),
      stableCitationId: this.generateStableCitationId(citation.document_id, citation.documents?.doc_type || 'unknown'),
      authorityScore: this.calculateAuthorityScoreFromMetadata(citation.documents),
      extractedFacts: citation.fact_summary ? [citation.fact_summary] : [],
      documentMetadata: citation.documents ? {
        title: citation.documents.title,
        docType: citation.documents.doc_type,
        publishedDate: citation.documents.published_date || citation.documents.granted_date || citation.documents.filed_date,
        authorityLevel: this.getAuthorityLevelFromDocType(citation.documents.doc_type)
      } : undefined
    }));

    console.log(`ðŸ“– Retrieved ${enhancedCitations.length} citations`);
    return enhancedCitations;
  }

  /**
   * Get citation statistics for conversation
   */
  async getCitationStatistics(): Promise<{
    totalCitations: number;
    uniqueDocuments: number;
    averageRelevanceScore: number;
    factsWithSummaries: number;
    authorityDistribution: Record<string, number>;
    mostCitedDocuments: Array<{ documentId: string; title: string; count: number }>;
  }> {
    // Get all citations for conversation
    const { data: messages } = await supabase
      .from('messages')
      .select('id')
      .eq('conversation_id', this.conversationId);

    if (!messages || messages.length === 0) {
      return {
        totalCitations: 0,
        uniqueDocuments: 0,
        averageRelevanceScore: 0,
        factsWithSummaries: 0,
        authorityDistribution: {},
        mostCitedDocuments: []
      };
    }

    const messageIds = messages.map(m => m.id);

    const { data: citations } = await supabase
      .from('message_citations')
      .select(`
        *,
        documents (title, doc_type)
      `)
      .in('message_id', messageIds);

    if (!citations) {
      return {
        totalCitations: 0,
        uniqueDocuments: 0,
        averageRelevanceScore: 0,
        factsWithSummaries: 0,
        authorityDistribution: {},
        mostCitedDocuments: []
      };
    }

    // Calculate statistics
    const uniqueDocuments = new Set(citations.map(c => c.document_id)).size;
    const averageRelevanceScore = citations
      .filter(c => c.relevance_score !== null)
      .reduce((sum, c) => sum + (c.relevance_score || 0), 0) / citations.length;
    
    const factsWithSummaries = citations.filter(c => c.fact_summary).length;

    // Authority distribution
    const authorityDistribution: Record<string, number> = {};
    citations.forEach(c => {
      if (c.documents?.doc_type) {
        const level = this.getAuthorityLevelFromDocType(c.documents.doc_type);
        authorityDistribution[level] = (authorityDistribution[level] || 0) + 1;
      }
    });

    // Most cited documents
    const documentCounts = new Map<string, { title: string; count: number }>();
    citations.forEach(c => {
      if (c.documents?.title) {
        const existing = documentCounts.get(c.document_id);
        documentCounts.set(c.document_id, {
          title: c.documents.title,
          count: existing ? existing.count + 1 : 1
        });
      }
    });

    const mostCitedDocuments = Array.from(documentCounts.entries())
      .map(([documentId, data]) => ({ documentId, ...data }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    return {
      totalCitations: citations.length,
      uniqueDocuments,
      averageRelevanceScore: Math.round(averageRelevanceScore * 100) / 100,
      factsWithSummaries,
      authorityDistribution,
      mostCitedDocuments
    };
  }

  /**
   * Clean up old citations beyond retention policy
   */
  async cleanupOldCitations(retentionDays: number = 30): Promise<number> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

    const { data: oldMessages } = await supabase
      .from('messages')
      .select('id')
      .eq('conversation_id', this.conversationId)
      .lt('created_at', cutoffDate.toISOString());

    if (!oldMessages || oldMessages.length === 0) {
      return 0;
    }

    const messageIds = oldMessages.map(m => m.id);
    const { error, count } = await supabase
      .from('message_citations')
      .delete()
      .in('message_id', messageIds);

    if (error) {
      console.error('Error cleaning up old citations:', error);
      return 0;
    }

    console.log(`ðŸ§¹ Cleaned up ${count || 0} old citations`);
    return count || 0;
  }

  // =======================
  // Private Helper Methods
  // =======================

  private async storeCitationsInDatabase(citations: EnhancedCitation[]): Promise<void> {
    const citationData = citations.map(c => ({
      message_id: c.messageId,
      document_id: c.documentId,
      chunk_id: c.chunkId,
      marker: c.marker,
      fact_summary: c.factSummary,
      page_range: c.pageRange,
      relevance_score: c.relevanceScore,
      citation_order: c.citationOrder
    }));

    const { error } = await supabase
      .from('message_citations')
      .insert(citationData);

    if (error) {
      console.error('Error storing citations:', error);
      throw error;
    }
  }

  private async updateConversationSources(
    searchResults: SearchResult[],
    factSummaries: FactSummary[]
  ): Promise<void> {
    const sourceUpdates = searchResults.map(result => {
      const factSummary = factSummaries.find(f => f.sourceId === result.documentId);
      return {
        conversation_id: this.conversationId,
        document_id: result.documentId,
        last_used_at: new Date().toISOString(),
        carry_score: Math.max(result.score, factSummary?.authorityScore || 0.5),
        pinned: false,
        turns_inactive: 0
      };
    });

    const { error } = await supabase
      .from('conversation_sources')
      .upsert(sourceUpdates, { 
        onConflict: 'conversation_id,document_id' 
      });

    if (error) {
      console.warn('Could not update conversation sources:', error);
    }
  }

  private generateStableCitationId(documentId: string, docType: string): string {
    const typePrefix = {
      'paper': 'P',
      'patent': 'T', 
      'note': 'N',
      'url': 'U',
      'book': 'B',
      'pdf': 'D'
    }[docType] || 'X';
    
    const shortId = documentId.substring(0, 8).replace(/-/g, '').toUpperCase();
    return `${typePrefix}${shortId}`;
  }

  private scoreSentence(sentence: string): number {
    let score = sentence.length / 100; // Base score from length
    
    if (/\d+/.test(sentence)) score += 2; // Numbers boost
    if (/method|process|result|finding|conclude|demonstrate|show|reveal|discover/i.test(sentence)) score += 3;
    if (sentence.length < 30 || sentence.length > 300) score *= 0.5; // Penalize extremes
    
    return score;
  }

  private calculateAuthorityScore(result: SearchResult): number {
    let score = 0.5 + Math.min(result.score, 0.3);
    
    const typeAuthority = {
      'patent': 0.9,
      'paper': 0.8,
      'book': 0.7,
      'pdf': 0.6,
      'note': 0.4,
      'url': 0.3
    }[result.docType] || 0.5;
    
    return Math.min(score * 0.7 + typeAuthority * 0.3, 1.0);
  }

  private calculateAuthorityScoreFromMetadata(metadata: any): number {
    if (!metadata) return 0.5;
    
    let score = 0.5;
    const typeAuthority = {
      'patent': 0.9,
      'paper': 0.8,
      'book': 0.7,
      'pdf': 0.6,
      'note': 0.4,
      'url': 0.3
    }[metadata.doc_type] || 0.5;
    
    score = typeAuthority;
    if (metadata.published_date || metadata.granted_date) score += 0.1;
    
    return Math.min(score, 1.0);
  }

  private extractPublishedDate(result: SearchResult): string | undefined {
    const metadata = result.metadata;
    if (metadata?.publishedDate) return metadata.publishedDate.toISOString().split('T')[0];
    if (metadata?.grantedDate) return metadata.grantedDate.toISOString().split('T')[0];
    if (metadata?.filedDate) return metadata.filedDate.toISOString().split('T')[0];
    return undefined;
  }

  private getAuthorityLevel(result: SearchResult): 'high' | 'medium' | 'low' {
    const score = this.calculateAuthorityScore(result);
    if (score >= 0.8) return 'high';
    if (score >= 0.6) return 'medium';
    return 'low';
  }

  private getAuthorityLevelFromDocType(docType: string): 'high' | 'medium' | 'low' {
    const highAuthority = ['patent', 'paper'];
    const mediumAuthority = ['book', 'pdf'];
    
    if (highAuthority.includes(docType)) return 'high';
    if (mediumAuthority.includes(docType)) return 'medium';
    return 'low';
  }
}

// =======================
// Convenience Functions
// =======================

/**
 * Create a citation persistence manager for a conversation
 */
export function createCitationManager(
  conversationId: string,
  options?: Partial<CitationPersistenceOptions>
): CitationPersistenceManager {
  return new CitationPersistenceManager(conversationId, options);
}

/**
 * Quick citation persistence for search results
 */
export async function persistSearchResultCitations(
  conversationId: string,
  messageId: string,
  searchResults: SearchResult[],
  factSummaries?: FactSummary[]
): Promise<CitationBatch> {
  const manager = createCitationManager(conversationId);
  return manager.persistCitations(messageId, searchResults, factSummaries);
}

/**
 * Retrieve citations with fact summaries for a message
 */
export async function getCitationsWithFacts(
  conversationId: string,
  messageId: string
): Promise<EnhancedCitation[]> {
  const manager = createCitationManager(conversationId);
  return manager.retrieveCitations(messageId, {
    includeFactSummaries: true,
    includeMetadata: true,
    sortByRelevance: true
  });
}

/**
 * Get comprehensive citation statistics for conversation analysis
 */
export async function getConversationCitationStats(
  conversationId: string
): Promise<{
  totalCitations: number;
  uniqueDocuments: number;
  averageRelevanceScore: number;
  factsWithSummaries: number;
  authorityDistribution: Record<string, number>;
  mostCitedDocuments: Array<{ documentId: string; title: string; count: number }>;
}> {
  const manager = createCitationManager(conversationId);
  return manager.getCitationStatistics();
}